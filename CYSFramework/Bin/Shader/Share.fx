/*
    화면에 출력되는 과정을 렌더링 파이프라인이라고 불린다.
    쉐이더는 GPU가 실행해주는 프로그램

    렌더링 파이프라인
    버텍스 쉐이더 : 정점을 정해주는 쉐이더 V

    헐 쉐이더 : 테셀레이션 이전의 단계 V
    테셀레이션 : 얼마나 삼각형을 쪼갤건지 포폴에서는 필요X 까다로움
    도메인 쉐이더 : 테셀레이션 단계의 끝, 테셀레이션의 위치값을 최종 계산 V

    지오메트리(기하) 쉐이더 : 여러 점을 조작할 수 있는 쉐이더 V
    레스터 라이즈 : 최종적으로 화면에 색을 출력하기 위한 단계, 점과 선을 최종적으로 계산하고 뷰포트 변환이 여기서 일어난다, 색을 칠할 준비한다.
    픽셀 쉐이더 : 최종 색을 결정한다. V

    컴퓨트 쉐이더 : 렌더링 파이프라인에 관련이 없는 편이다, 그래픽카드에 연산만 시키는 전용

    정점 쉐이더 : 정점의 변환을 담당한다.

    좌표계
    월드 변환 ( 로컬 좌표 -> 월드 좌표 )
       
    뷰 변환 ( 월드 좌표 -> 카메라 좌표, 카메라가 보는 물체만 나오게 한다. )
    
    투영 변환 ( 1. 카메라 좌표 -> 클립 좌표 -> 2. 원근 나누기 x y z w 중 w값을 이용해서 원근감을 적용 )

    변환은 전부 행렬로 이루어진다.

    V : 개발자가 쉐이더 코드를 작성한다.
*/

struct PS_Output_Single
{
    // 자료형 변수명 : 시멘틱
    // SV : 시스템 밸류 (시스템에 자동으로 넣어주는 값)
    // SV_TARGET을 하면 뒤에 0이 생략 된다. 숫자는 레지스터 넘버이다.
    // SV_TARGET0
    // 시멘틱을 통해서 내가 원하는 레지스터에 등록할 수 있다.
    float4 Color : SV_TARGET;
};

/////////////////////////////////
// 상수 레지스터
// 상수 버퍼
// C++의 값을 쉐이더로 보낼때 사용한다.
// 상수 버퍼와 구조화 버퍼(지금은 안씀) 등이 있다.

// 상수 레지스터 0번을 사용하겠다.
cbuffer Transform : register(b0)
{
    matrix gmatWorld;   // 월드 행렬
    matrix gmatView;    // 카메라(뷰) 행렬
    matrix gmatProj;    // 투영(프로젝션) 행렬
    matrix gmatWv;      // 월드 * 카메라
    matrix gmatWVP;     // 월드 * 카메라 * 투영
}